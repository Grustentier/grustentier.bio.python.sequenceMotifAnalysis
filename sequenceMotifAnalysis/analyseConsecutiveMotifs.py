'''
Created on 10.10.2021

@author: grustentier
'''

print("""


  ___                                                 __  __         _     _    __       _                   _               _               
 / __|  ___   __ _   _  _   ___   _ _    __   ___    |  \/  |  ___  | |_  (_)  / _|     /_\    _ _    __ _  | |  _  _   ___ (_)  _ _    __ _ 
 \__ \ / -_) / _` | | || | / -_) | ' \  / _| / -_)   | |\/| | / _ \ |  _| | | |  _|    / _ \  | ' \  / _` | | | | || | |_ / | | | ' \  / _` |
 |___/ \___| \__, |  \_,_| \___| |_||_| \__| \___|   |_|  |_| \___/  \__| |_| |_|     /_/ \_\ |_||_| \__,_| |_|  \_, | /__| |_| |_||_| \__, |
                |_|                                                                                              |__/                  |___/ 
  _  _          _            __  __         _     _    __     ___          _                _     _                                          
 | || |  _  _  | |__   ___  |  \/  |  ___  | |_  (_)  / _|   |   \   ___  | |_   ___   __  | |_  (_)  ___   _ _                              
 | __ | | || | | '_ \ |___| | |\/| | / _ \ |  _| | | |  _|   | |) | / -_) |  _| / -_) / _| |  _| | | / _ \ | ' \                             
 |_||_|  \_,_| |_.__/       |_|  |_| \___/  \__| |_| |_|     |___/  \___|  \__| \___| \__|  \__| |_| \___/ |_||_|                            
                                                                                                                                             
  _                ___                     _                  _     _                                                                        
 | |__   _  _     / __|  _ _   _  _   ___ | |_   ___   _ _   | |_  (_)  ___   _ _                                                            
 | '_ \ | || |   | (_ | | '_| | || | (_-< |  _| / -_) | ' \  |  _| | | / -_) | '_|                                                           
 |_.__/  \_, |    \___| |_|    \_,_| /__/  \__| \___| |_||_|  \__| |_| \___| |_|                                                             
         |__/                                                                                                                                


""")

'''
Analysis of the statistical occurrence of consecutive sequence motifs in membrane proteins.
It is a simple alternative to the HMM logo for visualizing frequently occurring motifs.
I will use information about the motif topology state (import from ./inputdata/motif-topologies.xml) generated by script analyseVariableMotifPositions.py script to label topology-unspecific motifs.
For example, a common motif in transmembrane has non-transmembrane amino acid properties like shown and described in paper:

Grunert, S., Labudde, D. 
Graph representation of high-dimensional alpha-helical membrane protein data. 
BioData Mining 6, 21 (2013). https://doi.org/10.1186/1756-0381-6-21
'''

import os
import sys
import argparse
import networkx as nx
import matplotlib.pyplot as plt 
import xml.etree.ElementTree as ET
sys.path.append(os.path.join(os.path.dirname(__file__), ".."))

from sequenceMotifAnalysis.includes import fileUtils as fU
from sequenceMotifAnalysis.includes import stringUtils as sU
from sequenceMotifAnalysis.includes import letters, dataCollecting as dC

parser = argparse.ArgumentParser(description='Code for analysis of variable sequence motif positions  for different topologies.')
parser.add_argument('--fasta_input_dir', default=os.path.dirname(__file__) + os.sep + 'inputdata' + os.sep + 'fasta' + os.sep + 'rhodopsins', help='Path to the input dir including fasta files.')
parser.add_argument('--tmhmm_input_dir', default=os.path.dirname(__file__) + os.sep + 'inputdata' + os.sep + 'tmhmm' + os.sep + 'rhodopsins', help='Path to the input dir including tmhmm files, generated extensive and  with no graphics.') 
parser.add_argument('--min_variable_positions', default=3, type=int, help='The min number of min variable x- position of a given sequence motif XYn by n-1 variable postions like GG4 = GxxxG')
parser.add_argument('--max_variable_positions', default=9, type=int, help='The max number of min variable x- position of a given sequence motif XYn by n-1 variable postions like GG4 = GxxxG')
parser.add_argument('--max_nodes', default=100, type=int, help='The max number of graph nodes to visualize') 
parser.add_argument('--topology', default="tm", type=str, help='The topology to analyse. (tm for transmembrane or ntm for none-transmembrane')
parser.add_argument('--as_tree', default=False, type=str, help='True or 1 for displaying graph as tree.')
 
arguments = parser.parse_args() 

    
def collectTopologySpecficSubSequences(fastaData, tmhmmData): 
    subsequences = [] 
   
    for data_tmhmm in tmhmmData:
        tmhmm_id = data_tmhmm["id"]
        current_fastaData = dC.findCorrespondingFastaData(tmhmm_id, fastaData)
        if current_fastaData is None:
            continue

        for area in data_tmhmm["areas"]:
            append = False
            if str(arguments.topology).lower() == "tm" and area["topology"] == "tmhelix":
                append = True                
            elif str(arguments.topology).lower() == "ntm" and (area["topology"] == "inside" or area["topology"] == "outside"):
                append = True
            else:append = False
            
            if append is True:       
                start_tmhmm = int(area["from"]) - 1
                end_tmhmm = int(area["to"]) - 1 
                subsequences.append(current_fastaData["sequence"][start_tmhmm:end_tmhmm])
                            
    return subsequences     


def printProgress(steps, maximum, name="progress", bar_length=20, width=20):  
    if maximum == 0:
        percent = 1.0
    else:
        percent = float(steps) / maximum
    arrow = '-' * int(round(percent * bar_length) - 1) + '>'
    spaces = ' ' * (bar_length - len(arrow))
    # sys.stdout.write("\r{0: <{1}} : [{2}]{3}%".format(name, width, arrow + spaces, int(round(percent*100))))
    sys.stdout.write("\r{0: <{1}}[{2}]{3}%".format("", 0, arrow + spaces, int(round(percent * 100))))
    sys.stdout.flush()    
    
    if steps >= maximum:     
        sys.stdout.write('\n\n')  

        
def createConsecutiveMotifsStatistics(topologySpecificSubSequences): 
    statistics = {}

    for sequence in topologySpecificSubSequences:        
        for i in range(0, len(sequence)):            
            for j in range(arguments.min_variable_positions, arguments.max_variable_positions + 1): 
                if (i + j) >= len(sequence):
                    continue    
                regEx1 = sequence[i] + sequence[i + j] + str(j)  
                motifSeq1 = sequence[i:i + j + 1]                 
                for l in range(arguments.min_variable_positions, arguments.max_variable_positions + 1):  
                    if (i + j + 1 + l) >= len(sequence):
                        continue
                    regEx2 = sequence[i + j + 1] + sequence[i + j + 1 + l] + str(l) 
                    motifSeq2 = sequence[i + j + 1:i + j + 1 + l + 1]                        
                    cmKey = regEx1 + "-" + regEx2                     
                    if cmKey not in statistics.keys():
                        statistics[cmKey] = {"sequence":sequence, "regEx1":regEx1, "regEx2":regEx2, "motifSequence1":motifSeq1, "motifSequence2":motifSeq2, "occurrence":1}
                    else:
                        statistics[cmKey]["occurrence"] += 1
        
    return statistics

        
def getTop(g, node):
    nodes = g.predecessors(node) 
    if len(list(nodes)) == 0: 
        return node
    for n in nodes:
        return getTop(g, n)        
    return None


def getDiGraph(statistics):
    graph = nx.DiGraph()
         
    if arguments.max_nodes is not None:
        statistics = statistics[0:arguments.max_nodes]
        
    for listEntry in statistics: 
        try:
            regEx1 = listEntry[1]["regEx1"]
            regEx2 = listEntry[1]["regEx2"] 
            graph.add_node(regEx1)
            graph.add_node(regEx2)
            # weight = listEntry[1]["occurrence"] * int(listEntry[1]["regEx1"][2:]) * int(listEntry[1]["regEx2"][2:])
            graph.add_edge(regEx1, regEx2, weight=listEntry[1]["occurrence"]) 
        except: 
            pass 
        
    return graph 


def getColorFromDatabase(regEx, motifTopologiesFilePath=os.path.dirname(__file__) + os.sep + 'inputdata' + os.sep + 'motif-topologies.xml'):
    colors = {False:"gray", None:"gray", "tm":"#cc4c48", "ntm":"#4ab3c9", "trans":"#8cb555"}    
    if os.path.exists(motifTopologiesFilePath) is False:return colors[False]
    
    tree = ET.parse(motifTopologiesFilePath)
    root = tree.getroot()

    motifElement = root.find(".//*[@regEx='" + regEx + "']")
    if motifElement is None:
        return colors[None] 
    
    return colors[motifElement.get("topology")]


def createGraph(statistics):
    statistics = sorted(statistics.items(), key=lambda x: x[1]["occurrence"], reverse=True)
    graph = getDiGraph(statistics)
    
    if sU.asBoolean(arguments.as_tree) is True:
        layout = nx.nx_pydot.graphviz_layout(graph, prog='dot')
    else:  
        layout = nx.nx_pydot.graphviz_layout(graph)
        
    labels = nx.get_edge_attributes(graph, 'weight')
    nx.draw_networkx_edge_labels(graph, layout, edge_labels=labels)
    colorMap = [getColorFromDatabase(node) for node in graph.nodes()]
    
    cent = nx.centrality.betweenness_centrality(graph, weight=None, normalized=False, endpoints=True) 
    nx.draw(graph, layout, width=1, linewidths=1, node_size=[v * 500 for v in cent.values()], node_color=colorMap, edge_color='silver', alpha=0.9, labels={node:node for node in graph.nodes()})
    plt.axis('off')
    
    print("\n\nCopy the following regExes and assing this to --regexes parameter within the analyseVariableMotifPositions.py script for analyzing variable motif positions.")
    print(str([node for node in graph.nodes()]).replace("'", "").replace("[", "").replace("]", ""))
    print("")


if __name__ == "__main__":  
    fastaFilePaths = fU.collectFilePaths(arguments.fasta_input_dir)
    assert len(fastaFilePaths) > 0, "No fasta files have been found!!!"
    tmhmmFilePaths = fU.collectFilePaths(arguments.tmhmm_input_dir)
    assert len(tmhmmFilePaths) > 0, "No tmhmm files have been found!!!"       
        
    AMINO_ACID_LETTERS = letters.AMINO_ACID_LETTERS_ALPHABETICAL
    
    steps = 5
    step = 0 
    
    printProgress(step, steps)
    step = step + 1 
    
    fastaData = dC.collectFastaData(fastaFilePaths)  
    printProgress(step, steps)
    step = step + 1
    
    tmhmmData = dC.collectTmhmmData(tmhmmFilePaths)
    printProgress(step, steps)
    step = step + 1 
    
    topologySpecificSubSequences = collectTopologySpecficSubSequences(fastaData, tmhmmData)
    printProgress(step, steps)
    step = step + 1
    
    statistics = createConsecutiveMotifsStatistics(topologySpecificSubSequences)
    printProgress(step, steps)
    step = step + 1  
    
    createGraph(statistics)
    printProgress(step, steps)
    step = step + 1  
    
    plt.show()    
    
